---
title: 'Copia profunda en JavaScript con structuredClone'
summary: 'JavaScript expone ahora structuredClone(), una funci칩n incorporada para copiar en profundidad.'
publishedAt: '2021-12-20'
tags:
  - clone
  - objects
  - javascript
banner: '/banners/copia-profunda-en-javascript-con-structured-clone.png'
---

Hace poco escrib칤 un art칤culo sobre [c칩mo clonar objectos en JavaScript](https://www.escuelafrontend.com/articulos/clonar-objetos-en-javascript) donde explico al menos 4 formas de hacerlo, pero no hab칤a hecho notar la existencia de `structuredClone` debido a que esta API todav칤a no estaba disponible en los navegadores. Pero hace poco [Firefox lanz칩 dicha API en su versi칩n 94](https://caniuse.com/?search=structuredClone) y Node 17 y Deno 1.14 la han implementado tambi칠n, y no va a pasar mucho tiempo para que los dem치s navegadores la implementen, por ello podemos empezar a utilizar esta funci칩n ahora mismo y no sentirnos mal por ello.

## Copias profundas

Hacer [una copia superficial](https://www.escuelafrontend.com/articulos/clonar-objetos-en-javascript) significa que los cambios en valores profundamente anidados ser치n visibles en la copia, as칤 como en el original. Lo contrario a ello es una copia profunda.

Un algoritmo de copia profunda tambi칠n copia las propiedades de un objeto una a una, pero se invoca a s칤 mismo recursivamente cuando encuentra una referencia a otro objeto, creando tambi칠n una copia de ese objeto. Esto puede ser muy importante para asegurar que dos piezas de c칩digo no compartan accidentalmente un objeto y manipulen sin saberlo el estado del otro.

Antes no hab칤a una forma f치cil o agradable de crear una copia profunda de un valor en JavaScript. La soluci칩n m치s com칰n a este problema era un hack basado en JSON:

```js
const myDeepCopy = JSON.parse(JSON.stringify(myOriginal));
```

De hecho, esta fue una soluci칩n tan popular, que V8 optimiz칩 agresivamente `JSON.parse()` y espec칤ficamente el patr칩n anterior para hacerlo lo m치s r치pido posible. Y aunque es r치pido, viene con un par de defectos y trampas:

- **Estructuras de datos recursivas:** `JSON.stringify()` se lanzar치 cuando le des una estructura de datos recursiva. Esto puede ocurrir f치cilmente cuando se trabaja con listas enlazadas o 치rboles.
- **Tipos incorporados:** `JSON.stringify()` se lanzar치 si el valor contiene otros tipos incorporados de JS como Map, Set, Date, RegExp o ArrayBuffer.
- **Funciones:** `JSON.stringify()` descartar치 silenciosamente las funciones.

## Clonaci칩n estructurada

La plataforma ya necesitaba la capacidad de crear copias profundas de valores JavaScript en un par de lugares: El almacenamiento de un valor JS en IndexedDB requiere alguna forma de serializaci칩n para que pueda ser almacenado en el disco y posteriormente deserializado para restaurar el valor JS. Del mismo modo, el env칤o de mensajes a un WebWorker a trav칠s de postMessage() requiere la transferencia de un valor JS de un 치mbito JS a otro. El algoritmo que se utiliza para esto se llama "Structured Clone", y hasta hace poco, no era f치cilmente accesible para los desarrolladores.

Esto ha cambiado. La especificaci칩n HTML fue modificada para exponer una funci칩n llamada `structuredClone()` que ejecuta exactamente ese algoritmo como medio para que los desarrolladores puedan crear f치cilmente copias profundas de valores JavaScript.

```js
const myDeepCopy = structuredClone(myOriginal);
```

Eso es todo. Esa es toda la API. Si quieres profundizar checa la [documentaci칩n en MDN](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone).

### Caracter칤sticas y limitaciones

La clonaci칩n estructurada resuelve muchas (aunque no todas) las deficiencias de la t칠cnica `JSON.stringify()`. La clonaci칩n estructurada puede manejar estructuras de datos c칤clicas, soporta muchos tipos de datos incorporados y es generalmente m치s robusta y a menudo m치s r치pida.

Sin embargo, sigue teniendo algunas limitaciones:

- **Prototipos:** Si utilizas `structuredClone()` con una instancia de clase, obtendr치s un objeto plano como valor de retorno, ya que la clonaci칩n estructurada descarta la cadena de prototipos del objeto.
- **Funciones:** Si el objeto contiene funciones, 칠stas ser치n descartadas silenciosamente.
- **No clonables:** Algunos valores no son clonables de forma estructurada, sobre todo los nodos `Error` y DOM.

Si alguna de estas limitaciones es un obst치culo para tu caso de uso, puedes usar la implementaci칩n de Lodash: [cloneDeep()](https://lodash.com/docs/4.17.15#cloneDeep).

### Rendimiento

[Surma hizo una comparaci칩n a principios de 2018](https://surma.dev/things/deep-copy/index.html), antes de que se expusiera `structuredClone()`. En ese entonces, `JSON.parse()` era la opci칩n m치s r치pida para objetos muy peque침os. Las t칠cnicas que se basaban en la clonaci칩n estructurada eran (significativamente) m치s r치pidas para los objetos m치s grandes. Considerando que el nuevo `structuredClone()` viene sin la sobrecarga de abusar de otras APIs y es m치s robusto que `JSON.parse()`, [Surma](https://twitter.com/DasSurma) recomienda que lo hagas tu enfoque por defecto para crear copias profundas.

## Conclusi칩n

Si necesitas crear una copia profunda de un valor en JS, ya sea porque utilizas estructuras de datos inmutables o porque quieres asegurarte de que una funci칩n puede manipular un objeto sin afectar al original, ya no necesitas buscar soluciones o bibliotecas. El ecosistema JS tiene ahora `structuredClone()`. Wujuuu!! 游봅

## Fuente

- [Deep-copying in JavaScript using structuredClone](https://web.dev/structured-clone/)
